```{julia}
using MissingLinks, Graphs, MetaGraphsNext, Logging, Mmap
using GTFS
import GeoFormatTypes as GFT
import TOML
import ProgressMeter
using Dates, DataFrames, DataFramesMeta, GeoDataFrames
import ArchGDAL as AG
import GeoFormatTypes as GFT
import Serialization: serialize
import StatsBase: competerank
import PedTransitAccess: create_pbfs
import MissingLinks: CandidateLink

config = TOML.parsefile(joinpath(@__DIR__, ".Renviron"))
DATA_PATH = config["DATA_PATH"]
```

```{julia}
# bbox: -79.2793,36.1195,-78.3099,35.5639
G = MissingLinks.graph_from_osm(
    joinpath(DATA_PATH, "data", "triangle.osm.pbf"),
    MissingLinks.DEFAULT_TRAVERSAL_SETTINGS,
    GFT.EPSG(32119) # State Plane NC, meters
)
```

```{julia}
@info "Graph has $(nv(G)) vertices and $(ne(G)) edges"
```

```{julia}
graph_to_gis(joinpath(DATA_PATH, "data", "graph_orig.gpkg"), G; crs=GFT.EPSG(32119))
```

## Load GTFS files for the Triangle

```{julia}
cht = GTFS.read(joinpath(DATA_PATH, "data", "gtfs", "cht.zip"))
gotriangle = GTFS.read(joinpath(DATA_PATH, "data", "gtfs", "gotriangle.zip"))
godurham = GTFS.read(joinpath(DATA_PATH, "data", "gtfs", "godurham.zip"))
goraleigh = GTFS.read(joinpath(DATA_PATH, "data", "gtfs", "goraleigh.zip"))
gocary = GTFS.read(joinpath(DATA_PATH, "data", "gtfs", "gocary.zip"))
```

## Number of trips by stop

This isn't perfect but it's a proxy for the value of the stop.

```{julia}
function stop_counts(feed, date)
    @assert ismissing(feed.frequencies) || nrow(feed.frequencies) == 0

    result = @chain feed.stop_times begin
        leftjoin(feed.trips, on=:trip_id)
        @subset(:service_id .∈ Ref(GTFS.services_active(feed, date)))
        # we don't have frequencies asserted above
        groupby(:stop_id)
        @combine(:trip_count=length(:stop_id))
        innerjoin(feed.stops, on=:stop_id)
        @rtransform :geom=AG.createpoint([:stop_lon, :stop_lat])
        metadata!("geometrycolumns", (:geom,))
        metadata!("crs", GFT.EPSG(4326))
        reproject(GFT.EPSG(32119), always_xy=true)
        select(:stop_id, :stop_name, :trip_count, :geom)
    end

    if nrow(result) == 0
        @warn "no served stops for $feed"
    end

    return result
end
```

```{julia}
all_stops = vcat(
    stop_counts(cht, Date(2024, 10, 4)), # A Thursday when the feed is valid
    stop_counts(gotriangle, Date(2025, 7, 17)),
    stop_counts(godurham, Date(2025, 7, 17)),
    stop_counts(gocary, Date(2025, 7, 17)),
    stop_counts(goraleigh, Date(2025, 7, 17))
)

metadata!(all_stops, "geometrycolumns", (:geom,))
metadata!(all_stops, "crs", GFT.EPSG(32119))

GeoDataFrames.write(joinpath(DATA_PATH, "data", "stops.gpkg"), all_stops; crs=GFT.EPSG(32119))
```

```{julia}
stop_vertices = MissingLinks.link_points!(G, all_stops.geom, create=true, tol=20)
```

## Partition graph

It's too big to run all at once

```{julia}
Gs = MissingLinks.partition(G, 6, 4, 1100)

@info "vertices per partition" nv.(Gs)
@info "edges per partition" ne.(Gs)
```

## Check that it worked

```{julia}
for r in 1:size(Gs, 1), c in 1:size(Gs, 2)
    graph_to_gis(joinpath(DATA_PATH, "data", "graph_partition.gpkg"), Gs[r, c];
    crs=GFT.EPSG(32119), layer_name="row_$(r)_col_$(c)", update=r != 1 || c != 1)
end
```

## Run the algorithm by partition

```{julia}
hu = GeoDataFrames.read(joinpath(DATA_PATH, "data", "hu.gpkg"))
origin_weights = create_graph_weights(G, hu, [:H1_001N], 1e-6)[:, 1]
```

```{julia}
algorithm_start = Dates.now()

all_candidate_links = Matrix{Vector{CandidateLink}}(undef, size(Gs))
# yes they all refer to the same object, but that's okay as this will be overwritten, not pushed to
fill!(all_candidate_links, CandidateLink[])
candidate_links = Matrix{Vector{CandidateLink}}(undef, size(Gs))
fill!(candidate_links, CandidateLink[])
score_matrix = Matrix{Vector{Float64}}(undef, size(Gs))
fill!(score_matrix, Float64[])

for r in 1:size(Gs, 1), c in 1:size(Gs, 2)
    @info "Row $r, column $c"

    Gsub = Gs[r, c]

    @info "creating weights"
    # Create the weights
    weights = zeros(Int32, nv(Gsub))
    for (vertex, count) ∈ zip(stop_vertices, all_stops.trip_count)
        if haskey(Gsub.G, vertex)
            weights[code_for(Gsub.G, vertex)] += count
        end
    end

    sub_origin_weights = MissingLinks.partition_weights(G, Gsub, origin_weights)

    open("distances.bin", "w") do dfile
        @info "Building distance matrix"
        dfile = open("distances.bin", "w+")
        matrix = Mmap.mmap(dfile, Matrix{UInt16}, (nv(Gsub), nv(Gsub)); grow=true)

        fill_distance_matrix!(Gsub, matrix; maxdist=1000)

        @info "Identifying candidate links"
        all_candidate_links[r, c] = identify_potential_missing_links(Gsub, matrix, 100, 500)

        @info "deduplicating links"
        candidate_links[r, c] = deduplicate_links(Gsub, all_candidate_links[r, c], matrix, 100)

        @info "scoring links"
        score_matrix[r, c] = score_links(x -> x < 1000, Gsub, candidate_links[r, c], matrix, sub_origin_weights, weights, 1000)
    end

    rm("distances.bin")
end

@info "Runtime: $(round((Dates.now() - algorithm_start), Minute))"
```

## Merge links back together

```{julia}
links, scores = MissingLinks.merge_links(G, Gs, candidate_links, score_matrix)
```

## Write output

```{julia}
ranks = competerank(scores, rev = true)

GeoDataFrames.write(
    joinpath(DATA_PATH, "data", "links.gpkg"),
    links_to_gis(G, links, "score"=>scores, "rank" => ranks)
)
```

## Insert top 100 links into network

```{julia}
create_pbfs(
    joinpath(DATA_PATH, "data", "triangle.osm.pbf"),
    joinpath(DATA_PATH, "networks", "baseline", "triangle-base.osm.pbf"),
    joinpath(DATA_PATH, "networks", "scenario", "triangle-scenario.osm.pbf"),
    links[ranks .≤ 100],
    G
)
```

## Create the Carolina Corporate Center link example

```{julia}
# note that this may not work if the OSM input data are changed and there are edits near Carolina Corporate Center
# to_edge_src is a split b/c of the transit stop
ccc = collect(filter(l -> l.fr_edge_src == VertexID(1431908213, :node) && l.to_edge_tgt == VertexID(6110164332, :node) && l.to_edge_src.type == :split, links))
@assert length(ccc) == 1
@assert first(ccc).geographic_length_m == 30

create_pbfs(
    joinpath(DATA_PATH, "data", "triangle.osm.pbf"),
    nothing,
    joinpath(DATA_PATH, "networks", "ccc", "triangle-ccc.osm.pbf"),
    ccc,
    G
)
```
