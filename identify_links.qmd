```{julia}
using MissingLinks, Graphs, MetaGraphsNext, Logging, Mmap
using GTFS
import GeoFormatTypes as GFT
import TOML
import ProgressMeter
using Dates, DataFrames, DataFramesMeta, GeoDataFrames
import ArchGDAL as AG
import GeoFormatTypes as GFT
import Serialization: serialize
import MissingLinks: CandidateLink
import StatsBase: competerank
import PedTransitAccess: create_pbfs

config = TOML.parsefile(joinpath(@__DIR__, ".Renviron"))
DATA_PATH = config["DATA_PATH"]
```

```{julia}
G = MissingLinks.graph_from_osm(
    joinpath(DATA_PATH, "data", "triangle.osm.pbf"),
    MissingLinks.TraversalPermissionSettings(),
    GFT.EPSG(32119) # State Plane NC, meters
)
```

```{julia}
G = remove_tiny_islands(G, 10)
```

```{julia}
@info "Graph has $(nv(G)) vertices and $(ne(G)) edges"
```

```{julia}
graph_to_gis(joinpath(DATA_PATH, "data", "graph_orig.gpkg"), G; crs=GFT.EPSG(32119))
```

## Load GTFS files for the Triangle

```{julia}
cht = GTFS.read(joinpath(DATA_PATH, "data", "gtfs", "cht.zip"))
gotriangle = GTFS.read(joinpath(DATA_PATH, "data", "gtfs", "gotriangle.zip"))
godurham = GTFS.read(joinpath(DATA_PATH, "data", "gtfs", "godurham.zip"))
goraleigh = GTFS.read(joinpath(DATA_PATH, "data", "gtfs", "goraleigh.zip"))
gocary = GTFS.read(joinpath(DATA_PATH, "data", "gtfs", "gocary.zip"))
```

## Number of trips by stop

This isn't perfect but it's a proxy for the value of the stop.

```{julia}
function stop_counts(feed, date)
    @assert ismissing(feed.frequencies) || nrow(feed.frequencies) == 0

    result = @chain feed.stop_times begin
        leftjoin(feed.trips, on=:trip_id)
        @subset(:service_id .∈ Ref(GTFS.services_active(feed, date)))
        # we don't have frequencies asserted above
        groupby(:stop_id)
        @combine(:trip_count=length(:stop_id))
        innerjoin(feed.stops, on=:stop_id)
        @rtransform :geom=AG.createpoint([:stop_lon, :stop_lat])
        metadata!("geometrycolumns", (:geom,))
        metadata!("crs", GFT.EPSG(4326))
        reproject(GFT.EPSG(32119), always_xy=true)
        select(:stop_id, :stop_name, :trip_count, :geom)
    end

    if nrow(result) == 0
        @warn "no served stops for $feed"
    end

    return result
end
```

```{julia}
all_stops = vcat(
    stop_counts(cht, Date(2024, 10, 4)), # A Thursday when the feed is valid
    stop_counts(gotriangle, Date(2025, 7, 17)),
    stop_counts(godurham, Date(2025, 7, 17)),
    stop_counts(gocary, Date(2025, 7, 17)),
    stop_counts(goraleigh, Date(2025, 7, 17))
)

metadata!(all_stops, "geometrycolumns", (:geom,))
metadata!(all_stops, "crs", GFT.EPSG(32119))
```

```{julia}
stop_vertices = MissingLinks.link_points!(G, all_stops.geom, create=true)
```

## Partition graph

It's too big to run all at once

```{julia}
Gs = MissingLinks.partition(G, 6, 4, 1000)

(nv.(Gs), ne.(Gs))
```

## Check that it worked

```{julia}
for r in 1:size(Gs, 1), c in 1:size(Gs, 2)
    graph_to_gis(joinpath(DATA_PATH, "data", "graph_partition.gpkg"), Gs[r, c];
    crs=GFT.EPSG(32119), layer_name="row_$(r)_col_$(c)", update=r != 1 || c != 1)
end
```

## Run the algorithm by partition

```{julia}
pop = GeoDataFrames.read(joinpath(DATA_PATH, "data", "population.gpkg"))
```

```{julia}
algorithm_start = Dates.now()

all_candidate_links = Matrix{Vector{CandidateLink}}(undef, size(Gs))
# yes they all refer to the same object, but that's okay as this will be overwritten, not pushed to
fill!(all_candidate_links, CandidateLink[])
candidate_links = Matrix{Vector{CandidateLink}}(undef, size(Gs))
fill!(candidate_links, CandidateLink[])
scores = Matrix{Vector{Float64}}(undef, size(Gs))
fill!(scores, Float64[])

for r in 1:size(Gs, 1), c in 1:size(Gs, 2)
    @info "Row $r, column $c"

    Gsub = Gs[r, c]

    @info "creating weights"
    # Create the weights
    weights = zeros(Int32, nv(Gsub))
    for (vertex, count) ∈ zip(stop_vertices, all_stops.trip_count)
        if haskey(Gsub, vertex)
            weights[code_for(Gsub, vertex)] += count
        end
    end

    origin_weights = create_graph_weights(Gsub, pop, [:P1_001N], 1e-6)[:, 1]

    open("distances.bin", "w") do dfile
        @info "Building distance matrix"
        dfile = open("distances.bin", "w+")
        matrix = Mmap.mmap(dfile, Matrix{UInt16}, (nv(Gsub), nv(Gsub)); grow=true)

        fill_distance_matrix!(Gsub, matrix; maxdist=1000)

        @info "Identifying candidate links"
        all_candidate_links[r, c] = identify_potential_missing_links(Gsub, matrix, 100, 500)

        @info "deduplicating links"
        candidate_links[r, c] = deduplicate_links(all_candidate_links[r, c], matrix, 100)

        @info "scoring links"
        scores[r, c] = score_links(x -> x < 1000, candidate_links[r, c], matrix, origin_weights, weights, 1000)
    end

    rm("distances.bin")
end

@info "Runtime: $(round((Dates.now() - algorithm_start), Minute))"
```

## Merge links back together

```{julia}
links, scores = MissingLinks.merge_links(G, Gs, candidate_links, scores)
```

## Write output

```{julia}
ranks = competerank(scores, rev = true)

GeoDataFrames.write(
    joinpath(DATA_PATH, "data", "links.gpkg"),
    links_to_gis(G, links, "score"=>scores, "rank" => ranks)
)
```

## Insert top 100 links into network

```{julia}
create_pbfs(
    joinpath(DATA_PATH, "data", "triangle.osm.pbf"),
    joinpath(DATA_PATH, "data", "triangle-base.osm.pbf"),
    joinpath(DATA_PATH, "data", "triangle-scenario.osm.pbf"),
    links[ranks .≤ 100],
    G
)
```

```{julia}
```